using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGeneratorsLibrary;

public class GeneratorInternal<TGenerator>
    where TGenerator : IIncrementalGenerator, new()
{
    private static Type Type => typeof(TGenerator);
    private static string Namespace => Type.Namespace;
    private static string AttributeName => Type.Name.Replace("Generator", "Attribute");
    private static string AttributeFullName => $"{Namespace}.{AttributeName}";

    protected static void CreateAttribute(IncrementalGeneratorInitializationContext context) =>
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource($"{AttributeName}.g.cs", SourceText.From(AttributeFile, Encoding.UTF8)));

    private static string AttributeFile => $$"""
        // <auto-generated />
        // {{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}}

        namespace {{Namespace}};

        [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        public sealed class {{AttributeName}} : System.Attribute {}
        """;

    protected static bool IsCandidate(SyntaxNode node) =>
        node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0;

    protected static INamedTypeSymbol? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol symbol)
            return null;

        var compilation = context.SemanticModel.Compilation;
        var attribute = compilation.GetTypeByMetadataName(AttributeFullName);
        if (attribute is null)
            return null;

        return symbol.GetAttributes().Any(a =>
            SymbolEqualityComparer.Default.Equals(a.AttributeClass, attribute))
            ? symbol
            : null;
    }
}
